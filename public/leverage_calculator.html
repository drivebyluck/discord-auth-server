<script>
function getDecimalPlaces(value) {
  if (!isNaN(value)) {
    const parts = value.toString().split(".");
    return parts.length > 1 ? parts[1].length : 0;
  }
  return 2;
}

function toggleMode(mode) {
  document.getElementById('controlledMode').style.display = 'none';
  document.getElementById('degenMode').style.display = 'none';
  document.getElementById('scalpMode').style.display = 'none';
  if (mode === 'controlled') document.getElementById('controlledMode').style.display = 'block';
  if (mode === 'degen') document.getElementById('degenMode').style.display = 'block';
  if (mode === 'scalp') document.getElementById('scalpMode').style.display = 'block';
}

function calculateControlled() {
  const investment = parseFloat(document.getElementById('c_investment').value);
  const profit = parseFloat(document.getElementById('c_profit').value);
  const loss = parseFloat(document.getElementById('c_loss').value);
  const leverage = parseFloat(document.getElementById('c_leverage').value);
  const entry = parseFloat(document.getElementById('c_entry').value);
  const direction = document.getElementById('c_direction').value;

  if (isNaN(investment) || isNaN(profit) || isNaN(loss) || isNaN(leverage) || isNaN(entry)) {
    document.getElementById('c_result').textContent = "You must fill all fields before calculation.";
    return;
  }

  let tp, sl;
  const move = (profit / (investment * leverage)) * entry;
  const stop = (loss / (investment * leverage)) * entry;

  if (direction === "Long") {
    tp = entry + move;
    sl = entry - stop;
  } else {
    tp = entry - move;
    sl = entry + stop;
  }

  const dec = getDecimalPlaces(entry);
  document.getElementById('c_result').textContent = `Take Profit: $${tp.toFixed(dec)} | Stop Loss: $${sl.toFixed(dec)}`;
}

function calculateDegen() {
  const investment = parseFloat(document.getElementById('d_investment').value);
  const profit = parseFloat(document.getElementById('d_profit').value);
  const loss = parseFloat(document.getElementById('d_loss').value);
  const entry = parseFloat(document.getElementById('d_entry').value);
  const exit = parseFloat(document.getElementById('d_exit').value);
  const direction = document.getElementById('d_direction').value;

  if (isNaN(investment) || isNaN(profit) || isNaN(loss) || isNaN(entry) || isNaN(exit)) {
    document.getElementById('d_result').textContent = "You must fill all fields before calculation.";
    return;
  }

  if ((direction === "Long" && exit <= entry) || (direction === "Short" && exit >= entry)) {
    document.getElementById('d_result').textContent = "Invalid exit price for selected direction.";
    return;
  }

  const leverage = Math.abs((profit / investment) / Math.abs(exit - entry) * entry);
  const move = (loss / (investment * leverage)) * entry;
  const sl = direction === "Long" ? entry - move : entry + move;
  const dec = getDecimalPlaces(entry);

  document.getElementById('d_result').textContent = `Leverage: ${leverage.toFixed(dec)} | Stop Loss: $${sl.toFixed(dec)}`;
}

function calculateScalp() {
  const entry = parseFloat(document.getElementById('entryPriceScalp').value);
  const invest = parseFloat(document.getElementById('investmentScalp').value);
  const gainPct = parseFloat(document.getElementById('gainScalp').value);
  const direction = document.getElementById('directionScalp').value;

  if (isNaN(entry) || isNaN(invest) || isNaN(gainPct)) {
    document.getElementById('scalpResults').textContent = "You must fill all fields before calculation.";
    return;
  }

  const dec = getDecimalPlaces(entry);
  const gain = invest * (gainPct / 100);
  const risk = invest * 0.05;
  const results = [];

  [10, 20, 30, 40, 50].forEach(lev => {
    const positionSize = invest * lev;
    const tpMove = gain / positionSize;
    const slMove = risk / positionSize;
    let tp, sl;

    if (direction === "long") {
      tp = entry * (1 + tpMove);
      sl = entry * (1 - slMove);
    } else {
      tp = entry * (1 - tpMove);
      sl = entry * (1 + slMove);
    }

    results.push(`<div><b>${lev}x</b><br>Take Profit: $${tp.toFixed(dec)}<br>Stop Loss: $${sl.toFixed(dec)}</div>`);
  });

  document.getElementById("scalpResults").innerHTML = results.join("<br><br>");
}

const allLevels = [
  8.12, 23.80, 39.50, 49.99, 58.40, 63.25, 75.90, 89.50, 102.75, 115.30,
  123.45, 135.00, 143.25, 150.70, 160.10, 168.90, 178.40, 185.60, 195.25,
  205.00, 215.90, 225.40, 230.80, 240.50, 250.00, 260.60, 275.80, 289.90, 295.00
];

async function fetchSOLPrice() {
  try {
    const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
    const data = await res.json();
    return data.solana.usd;
  } catch (err) {
    console.error("Error fetching SOL price:", err);
    return null;
  }
}

function getClosestLevels(price) {
  const sorted = [...allLevels].sort((a, b) => a - b);
  const supports = sorted.filter(lvl => lvl < price).slice(-3);
  const resistances = sorted.filter(lvl => lvl > price).slice(0, 3);
  return { supports, resistances };
}

async function generateStrategy() {
  const investment = parseFloat(document.getElementById("gen-investment").value);
  const target = parseFloat(document.getElementById("gen-profit").value);
  const days = parseFloat(document.getElementById("gen-days").value);
  const price = await fetchSOLPrice();

  if (!investment || !target || !days || !price) {
    document.getElementById("gen-result").innerHTML = "You must fill all fields before calculation.";
    return;
  }

  const { supports, resistances } = getClosestLevels(price);
  const strategy = `
    <strong>SOL Live Price:</strong> $${price.toFixed(2)}<br>
    <strong>Support Levels:</strong> $${supports.join(", $")}<br>
    <strong>Resistance Levels:</strong> $${resistances.join(", $")}<br>
    <strong>Strategy:</strong> Go long if it bounces from $${supports[2]}, short if rejected from $${resistances[0]}.<br>
    <strong>Daily Target:</strong> $${(target / days).toFixed(2)}
  `;
  document.getElementById("gen-result").innerHTML = strategy;
}
</script>
</body>
</html>
